% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spoar.R
\name{SpoaAlgo}
\alias{SpoaAlgo}
\alias{spoaAlign}
\alias{spoaAlign.character}
\alias{spoaAlign.XStringSet}
\alias{spoaAlign.QualityScaledXStringSet}
\alias{spoaAlign.ShortReadQ}
\alias{spoaAlign.derep}
\alias{spoaConsensus}
\alias{spoaConsensus.character}
\alias{spoaConsensus.XStringSet}
\alias{spoaConsensus.ShortRead}
\alias{spoaConsensus.QualityScaledXStringSet}
\alias{spoaConsensus.ShortReadQ}
\alias{spoaConsensus.derep}
\title{Specify an algorithm for SPOA}
\usage{
SpoaAlgo(
  algorithm = c("local", "global", "semi.global"),
  m = 5L,
  n = -4L,
  g = -8L,
  e = g,
  q = g,
  c = q
)

spoaAlign(seq, algo = spoaAlgo(), ...)

\method{spoaAlign}{character}(seq, algo = spoaAlgo(), w = 1, qual = NULL, ...)

\method{spoaAlign}{XStringSet}(seq, algo = spoaAlgo(), w = 1, qual = NULL, ...)

\method{spoaAlign}{QualityScaledXStringSet}(seq, algo = spoaAlgo(), w = 1, ...)

\method{spoaAlign}{ShortReadQ}(seq, algo = spoaAlgo(), w = 1, ...)

\method{spoaAlign}{derep}(seq, algo = spoaAlgo(), ...)

spoaConsensus(seq, algo = spoaAlgo(), ...)

\method{spoaConsensus}{character}(seq, algo = spoaAlgo(), w = 1, qual = NULL, ...)

\method{spoaConsensus}{XStringSet}(seq, algo = spoaAlgo(), w = 1, qual = NULL, ...)

\method{spoaConsensus}{ShortRead}(seq, algo = spoaAlgo(), w = 1, qual = NULL, ...)

\method{spoaConsensus}{QualityScaledXStringSet}(seq, algo = spoaAlgo(), w = 1, ...)

\method{spoaConsensus}{ShortReadQ}(seq, algo = spoaAlgo(), w = 1, ...)

\method{spoaConsensus}{derep}(seq, algo = spoaAlgo(), ...)
}
\arguments{
\item{algorithm}{(\code{character} string) alignment mode; one of \code{"local"}
(Smith-Watterman), \code{"global"} (Needleman-Wunsch), or \code{"semi.global"}
(Overlap). \emph{Default}: \code{"local"}}

\item{m}{(non-negative \code{integer}) score for a match. \emph{Default}: \code{5L}}

\item{n}{(non-positive \code{integer}) score for a mismatch. \emph{Default}: \code{-4L}}

\item{g}{(non-positive \code{integer}) gap opening penalty. \emph{Default}: \code{-8L}}

\item{e}{(non-positive \code{integer}) gap extension penalty. \emph{Default}: same
value as \code{g}}

\item{q}{(non-positive \code{integer}) second gap opening penalty.
\emph{Default}: same value as \code{g}}

\item{c}{(non-positive \code{integer}) second gap extension penalty.
\emph{Default}: same value as \code{e}}

\item{seq}{(\code{character} vector, \code{\link[Biostrings:XStringSet-class]{Biostrings::XStringSet}},
\code{\link[ShortRead:ShortRead-class]{ShortRead::ShortRead}}, or \code{\link[dada2:derep-class]{dada2::derep}}) sequences to
align.}

\item{algo}{(\code{spoaAlgo} object) parameters for SPOA, generated by
\code{\link[=spoaAlgo]{spoaAlgo()}}.}

\item{...}{additional parameters passed to methods}

\item{w}{(\code{integer} vector) weights for the sequences. \emph{Default}: \code{1L}}

\item{qual}{(\code{list} of \code{numeric} vectors) per-base quality scores for the
sequences. \emph{Default}: none}
}
\value{
an object of class "\code{SpoaAlgo}", suitable for passing to
\code{\link[=spoaAlign]{spoaAlign()}} or \code{\link[=spoaConsensus]{spoaConsensus()}}

For \code{spoaConsensus()}, either a \code{character} string or the
appropriate \code{\link[Biostrings:XString-class]{Biostrings::XString}}, depending on the class of \code{seq}.

For \code{spoaAlign()}, either a
\code{character} vector or a \code{\link[Biostrings:MultipleAlignment-class]{Biostrings::MultipleAlignment}}, depending on
the class of \code{seq}. If \code{seq} is a \code{BStringSet} (i.e., an \code{XStringSet} which
is not specifically DNA, RNA, or AA) then the result is also a \code{BStringSet},
since there is no corresponding "\code{BMultipleAlignment}" class. If \code{seq} is a
\code{\link[ShortRead:ShortRead-class]{ShortRead::ShortRead}} object, the output is a
\code{\link[Biostrings:MultipleAlignment-class]{Biostrings::DNAMultipleAlignment}}.\tabular{lll}{
   \strong{seq} \tab \strong{spoaConsensus} \tab \strong{spoaAlign} \cr
   \code{character(n)} \tab \code{character(1)} \tab \code{character(n)} \cr
   \code{\link[Biostrings:XStringSet-class]{BStringSet}} \tab \code{\link[Biostrings:XString-class]{BString}} \tab \code{\link[Biostrings:XStringSet-class]{BStringSet}} \cr
   \code{\link[Biostrings:XStringSet-class]{DNAStringSet}} \tab \code{\link[Biostrings:XString-class]{DNAString}} \tab \code{\link[Biostrings:MultipleAlignment-class]{DNAMultipleAlignment}} \cr
   \code{\link[Biostrings:XStringSet-class]{RNAStringSet}} \tab \code{\link[Biostrings:XString-class]{RNAString}} \tab \code{\link[Biostrings:MultipleAlignment-class]{RNAMultipleAlignment}} \cr
   \code{\link[Biostrings:XStringSet-class]{AAStringSet}} \tab \code{\link[Biostrings:XString-class]{AAString}} \tab \code{\link[Biostrings:MultipleAlignment-class]{AAMultipleAlignment}} \cr
   \code{\link[Biostrings:QualityScaledXStringSet-class]{QualityScaledBStringSet}} \tab \code{\link[Biostrings:XString-class]{BString}} \tab \code{\link[Biostrings:XStringSet-class]{BStringSet}} \cr
   \code{\link[Biostrings:QualityScaledXStringSet-class]{QualityScaledDNAStringSet}} \tab \code{\link[Biostrings:XString-class]{DNAString}} \tab \code{\link[Biostrings:MultipleAlignment-class]{DNAMultipleAlignment}} \cr
   \code{\link[Biostrings:QualityScaledXStringSet-class]{QualityScaledRNAStringSet}} \tab \code{\link[Biostrings:XString-class]{RNAString}} \tab \code{\link[Biostrings:MultipleAlignment-class]{RNAMultipleAlignment}} \cr
   \code{\link[Biostrings:QualityScaledXStringSet-class]{QualityScaledAAStringSet}} \tab \code{\link[Biostrings:XString-class]{AAString}} \tab \code{\link[Biostrings:MultipleAlignment-class]{AAMultipleAlignment}} \cr
   \code{\link[ShortRead:ShortReadQ-class]{ShortReadQ}} \tab \code{\link[Biostrings:XString-class]{DNAString}} \tab \code{\link[Biostrings:MultipleAlignment-class]{DNAMultipleAlignment}} \cr
   \code{\link[dada2:derep-class]{derep}} \tab \code{character(1)} \tab \code{character(n)} \cr
}
}
\description{
Specify an algorithm for SPOA

Align sequences using SPOA (and optionally get the consensus)
}
\details{
\subsection{Gap penalties}{

The general (convex) gap penalty formula is:

\code{min(g + (i - i) * e, q + (i - 1) * c)}

For \code{q == g} and \code{c == e} (as is the case unless \code{q} or \code{c} is explicitly
set), this simplifies to the affine gap penalty:

\code{g + (i - 1) * e}

If, additionally, \code{e == g} (the default), then this is the linear gap
penalty:

\code{g * i}
}

\subsection{Weighting}{

Assigning a weight \emph{w} to a sequence is equivalent to including that sequence
\emph{w} times; this is primarily useful for dereplicated sequences, where all
sequences are unique, and the weight represents their multiplicity.

Note that POA is not order-independent, so results may differ when a set of
non-unique sequences is dereplicated. For the most predictable results, it
is recommended to sort dereplicated sequences in decreasing order of
abundance (as in \code{\link[dada2:derepFastq]{dada2::derepFastq()}}).
}

\subsection{Quality scores}{

If \code{seq} is an object which includes quality scores
(\code{\link[Biostrings:QualityScaledXStringSet-class]{Biostrings::QualityScaledXStringSet}}, \code{\link[ShortRead:ShortReadQ-class]{ShortRead::ShortReadQ}},
or \code{\link[dada2:derep-class]{dada2::derep}})
then the alignment consensus is weighted using the quality scores. The method
used by SPOA uses the integer quality scores as per-position weights
analogous to sequence weights; i.e., if two different bases align in the same
position, one in a single sequence with quality score 40 and the other in a
single sequence with quality score 20, then this is equivalent to the first
base occurring at that position in 40 sequences without quality scores, and
the second base occurring at that position in 20 sequences without quality
scores.

It is possible to use a combination of sequence weights and quality scores.
In this case, in order for a dereplicated sequence set to give the same
results as the non-dereplicated sequences, the quality score for each of the
dereplicated sequences should be the mean of the quality scores for the
corresponding non-dereplicated sequences. This is the method used to generate
quality scores for dereplicated sequences in \code{\link[dada2:derepFastq]{dada2::derepFastq()}}.
}
}
\examples{
sequences <- c(
    "CATAAAAGAACGTAGGTCGCCCGTCCGTAACCTGTCGGATCACCGGAAAGGACCCGTAAAGTGATAATGAT",
    "ATAAAGGCAGTCGCTCTGTAAGCTGTCGATTCACCGGAAAGATGGCGTTACCACGTAAAGTGATAATGATTAT",
    "ATCAAAGAACGTGTAGCCTGTCCGTAATCTAGCGCATTTCACACGAGACCCGCGTAATGGG",
    "CGTAAATAGGTAATGATTATCATTACATATCACAACTAGGGCCGTATTAATCATGATATCATCA",
    "GTCGCTAGAGGCATCGTGAGTCGCTTCCGTACCGCAAGGATGACGAGTCACTTAAAGTGATAAT",
    "CCGTAACCTTCATCGGATCACCGGAAAGGACCCGTAAATAGACCTGATTATCATCTACAT"
)
spoaAlign(sequences)
spoaConsensus(sequences)
}
